# -----------------------------------------------------------------------------
# Quality Checks Workflow
# -----------------------------------------------------------------------------
# This workflow runs various quality checks on the codebase including:
# - Linting
# - Type checking
# - Unit tests
# - Format checking
# - Build verification
# - Security scanning
# - AI-powered code quality and security analysis
#
# Example usage in another workflow:
# ```yaml
# quality:
#   uses: ./.github/workflows/quality.yml
#   with:
#     node_version: '20.x'
#     package_manager: 'npm'
#     skip_security: true
#   secrets:
#     PAT: ${{ secrets.GITHUB_TOKEN }}
#     ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
# ```

name: üîç Quality Checks

on:
  workflow_call:
    inputs:
      node_version:
        description: 'Node.js version to use'
        required: false
        default: '20.x'
        type: string
      package_manager:
        description: 'Package manager to use (npm, yarn, or bun)'
        required: false
        default: 'npm'
        type: string
      skip_lint:
        description: 'Skip the lint job'
        required: false
        default: false
        type: boolean
      skip_typecheck:
        description: 'Skip the typecheck job'
        required: false
        default: false
        type: boolean
      skip_test:
        description: 'Skip the test job'
        required: false
        default: false
        type: boolean
      skip_format:
        description: 'Skip the format check job'
        required: false
        default: false
        type: boolean
      skip_build:
        description: 'Skip the build job'
        required: false
        default: false
        type: boolean
      skip_security:
        description: 'Skip the security scan job'
        required: false
        default: false
        type: boolean
      skip_jobs:
        description: 'Jobs to skip (comma-separated: lint,typecheck,test,format,build,security,code_quality_check,claude_security_scan,quality,github_issue)'
        required: false
        default: ''
        type: string
      working_directory:
        description: 'Directory to run commands in (if not root)'
        required: false
        default: ''
        type: string
    secrets:
      PAT:
        description: 'Personal Access Token for GitHub operations'
        required: false
      ANTHROPIC_API_KEY:
        description: 'Anthropic API key for Claude code quality integrations'
        required: false

# Concurrency is managed by the parent workflow that calls this one
# This avoids deadlocks between parent and child workflows

jobs:
  lint:
    name: üßπ Lint
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: ${{ !inputs.skip_lint && !contains(inputs.skip_jobs, 'lint') }}

    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node_version }}
          cache: ${{ inputs.package_manager }}

      - name: üì¶ Install dependencies
        run: |
          if [ "${{ inputs.package_manager }}" = "npm" ]; then
            npm ci
          elif [ "${{ inputs.package_manager }}" = "yarn" ]; then
            yarn install --frozen-lockfile
          elif [ "${{ inputs.package_manager }}" = "bun" ]; then
            bun install --frozen-lockfile
          else
            echo "Unsupported package manager: ${{ inputs.package_manager }}"
            exit 1
          fi
        working-directory: ${{ inputs.working_directory || '.' }}

      - name: üßπ Run linter
        run: ${{ inputs.package_manager }} run lint
        working-directory: ${{ inputs.working_directory || '.' }}

  typecheck:
    name: üîç Type Check
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: ${{ !inputs.skip_typecheck && !contains(inputs.skip_jobs, 'typecheck') }}

    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node_version }}
          cache: ${{ inputs.package_manager }}

      - name: üì¶ Install dependencies
        run: |
          if [ "${{ inputs.package_manager }}" = "npm" ]; then
            npm ci
          elif [ "${{ inputs.package_manager }}" = "yarn" ]; then
            yarn install --frozen-lockfile
          elif [ "${{ inputs.package_manager }}" = "bun" ]; then
            bun install --frozen-lockfile
          else
            echo "Unsupported package manager: ${{ inputs.package_manager }}"
            exit 1
          fi
        working-directory: ${{ inputs.working_directory || '.' }}

      - name: üîç Run type check
        run: ${{ inputs.package_manager }} run typecheck
        working-directory: ${{ inputs.working_directory || '.' }}

  test:
    name: üß™ Run Tests
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: ${{ !inputs.skip_test && !contains(inputs.skip_jobs, 'test') }}

    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node_version }}
          cache: ${{ inputs.package_manager }}

      - name: üì¶ Install dependencies
        run: |
          if [ "${{ inputs.package_manager }}" = "npm" ]; then
            npm ci
          elif [ "${{ inputs.package_manager }}" = "yarn" ]; then
            yarn install --frozen-lockfile
          elif [ "${{ inputs.package_manager }}" = "bun" ]; then
            bun install --frozen-lockfile
          else
            echo "Unsupported package manager: ${{ inputs.package_manager }}"
            exit 1
          fi
        working-directory: ${{ inputs.working_directory || '.' }}

      - name: üß™ Run tests
        run: |
          if [ "${{ inputs.package_manager }}" = "npm" ]; then
            npm test
          elif [ "${{ inputs.package_manager }}" = "yarn" ]; then
            yarn test
          elif [ "${{ inputs.package_manager }}" = "bun" ]; then
            bun test
          fi
        working-directory: ${{ inputs.working_directory || '.' }}

  format:
    name: üìê Check Formatting
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: ${{ !inputs.skip_format && !contains(inputs.skip_jobs, 'format') }}

    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node_version }}
          cache: ${{ inputs.package_manager }}

      - name: üì¶ Install dependencies
        run: |
          if [ "${{ inputs.package_manager }}" = "npm" ]; then
            npm ci
          elif [ "${{ inputs.package_manager }}" = "yarn" ]; then
            yarn install --frozen-lockfile
          elif [ "${{ inputs.package_manager }}" = "bun" ]; then
            bun install --frozen-lockfile
          else
            echo "Unsupported package manager: ${{ inputs.package_manager }}"
            exit 1
          fi
        working-directory: ${{ inputs.working_directory || '.' }}

      - name: üìê Check formatting
        run: ${{ inputs.package_manager }} run format:check
        working-directory: ${{ inputs.working_directory || '.' }}

  build:
    name: üèóÔ∏è Build
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: ${{ !inputs.skip_build && !contains(inputs.skip_jobs, 'build') }}

    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node_version }}
          cache: ${{ inputs.package_manager }}

      - name: üì¶ Install dependencies
        run: |
          if [ "${{ inputs.package_manager }}" = "npm" ]; then
            npm ci
          elif [ "${{ inputs.package_manager }}" = "yarn" ]; then
            yarn install --frozen-lockfile
          elif [ "${{ inputs.package_manager }}" = "bun" ]; then
            bun install --frozen-lockfile
          else
            echo "Unsupported package manager: ${{ inputs.package_manager }}"
            exit 1
          fi
        working-directory: ${{ inputs.working_directory || '.' }}

      - name: üèóÔ∏è Build project
        run: ${{ inputs.package_manager }} run build
        working-directory: ${{ inputs.working_directory || '.' }}

  security:
    name: üîí Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: ${{ !inputs.skip_security && !contains(inputs.skip_jobs, 'security') }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node_version }}
          cache: ${{ inputs.package_manager }}

      - name: üì¶ Install dependencies
        run: |
          if [ "${{ inputs.package_manager }}" = "npm" ]; then
            npm ci
          elif [ "${{ inputs.package_manager }}" = "yarn" ]; then
            yarn install --frozen-lockfile
          elif [ "${{ inputs.package_manager }}" = "bun" ]; then
            bun install --frozen-lockfile
          else
            echo "Unsupported package manager: ${{ inputs.package_manager }}"
            exit 1
          fi
        working-directory: ${{ inputs.working_directory || '.' }}

      - name: üîí Run security audit
        run: |
          if [ "${{ inputs.package_manager }}" = "npm" ]; then
            npm audit --production
          elif [ "${{ inputs.package_manager }}" = "yarn" ]; then
            yarn audit --groups dependencies
          elif [ "${{ inputs.package_manager }}" = "bun" ]; then
            bun pm audit
          else
            echo "Unsupported package manager: ${{ inputs.package_manager }}"
            exit 1
          fi
        working-directory: ${{ inputs.working_directory || '.' }}

  code_quality_check:
    name: ü§ñ Claude Code Quality Check
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: ${{ !contains(inputs.skip_jobs, 'code_quality_check') }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node_version }}
          cache: ${{ inputs.package_manager }}

      - name: üì¶ Install dependencies
        run: |
          if [ "${{ inputs.package_manager }}" = "npm" ]; then
            npm ci
          elif [ "${{ inputs.package_manager }}" = "yarn" ]; then
            yarn install --frozen-lockfile
          elif [ "${{ inputs.package_manager }}" = "bun" ]; then
            bun install --frozen-lockfile
          else
            echo "Unsupported package manager: ${{ inputs.package_manager }}"
            exit 1
          fi
        working-directory: ${{ inputs.working_directory || '.' }}

      - name: ü§ñ Install Claude CLI
        run: |
          # Use npm as the default package manager if not specified
          PACKAGE_MANAGER="${{ inputs.package_manager }}"
          if [ -z "$PACKAGE_MANAGER" ]; then
            PACKAGE_MANAGER="npm"
            echo "Package manager not specified, using npm as default"
          fi

          if [ "$PACKAGE_MANAGER" = "npm" ]; then
            npm install -g @anthropic-ai/claude-code
          elif [ "$PACKAGE_MANAGER" = "yarn" ]; then
            yarn global add @anthropic-ai/claude-code
          elif [ "$PACKAGE_MANAGER" = "bun" ]; then
            bun add -g @anthropic-ai/claude-code
          else
            echo "Unsupported package manager: $PACKAGE_MANAGER"
            exit 1
          fi

      - name: üîç Run Claude code quality check
        id: code_review
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          # Create basic prompt
          cat > code_review_prompt.txt << 'EOF'
          Perform a code review on the provided code changes. Focus on code quality, best practices, and potential bugs.
          EOF

          # Check if guidelines file exists in the repository and append it
          if [ -f "docs/code_review_guidelines.md" ]; then
            cat docs/code_review_guidelines.md >> code_review_prompt.txt
            echo "Using custom guidelines from docs/code_review_guidelines.md"
          else
            # Fallback to default guidelines if the file doesn't exist
            cat >> code_review_prompt.txt << 'EOF'

          IMPORTANT GUIDELINES:
          - IGNORE any files that would be excluded by .gitignore (e.g., node_modules/, dist/, build/, coverage/)
          - DO NOT review generated files, compiled code, or third-party dependencies
          - Focus on substantive code issues rather than trivial style issues
          - Be concise and specific in your feedback
          - When suggesting improvements, explain why they matter
          - End your review with "VERDICT: PASS" if the code is acceptable for deployment
          - End your review with "VERDICT: FAIL" if there are critical issues that must be fixed before deployment
          EOF
            echo "Using default guidelines (docs/code_review_guidelines.md not found)"
          fi

          # Initialize failure flag
          REVIEW_FAILED=0

          # Create markdown file for results
          RESULTS_FILE="code_review_results.md"
          echo "# Claude AI Code Review Results" > $RESULTS_FILE
          echo "" >> $RESULTS_FILE
          echo "Generated on: $(date)" >> $RESULTS_FILE
          echo "" >> $RESULTS_FILE

          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # For pull requests, add PR info
            echo "## Pull Request #${{ github.event.pull_request.number }}" >> $RESULTS_FILE
            echo "" >> $RESULTS_FILE
            echo "- Title: ${{ github.event.pull_request.title }}" >> $RESULTS_FILE
            echo "- Author: ${{ github.event.pull_request.user.login }}" >> $RESULTS_FILE
            echo "- Branch: ${{ github.head_ref }}" >> $RESULTS_FILE
            echo "" >> $RESULTS_FILE
            
            echo "üîç Reviewing files changed in PR #${{ github.event.pull_request.number }}"
            
            # Get all files to review
            files_to_review=$(git diff -U0 --name-only ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} | \
                              grep -E '\.(js|jsx|ts|tsx|css|scss|html|md)$' | \
                              grep -v -E 'node_modules/|dist/|build/|coverage/')
            
            # Add TOC to markdown file
            echo "## Files Reviewed" >> $RESULTS_FILE
            echo "" >> $RESULTS_FILE
            for file in $files_to_review; do
              echo "- [${file}](#$(echo ${file} | sed 's/[^a-zA-Z0-9]/-/g' | tr '[:upper:]' '[:lower:]'))" >> $RESULTS_FILE
            done
            echo "" >> $RESULTS_FILE
            
            # Process each file
            for file in $files_to_review; do
              echo "üìù Reviewing $file"
              review_output=$(git diff -U0 ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} -- "$file" | \
                            claude -p "$(cat code_review_prompt.txt)" --output-format json)
              
              # Extract the review text
              review_text=$(echo "$review_output" | jq -r ".result")
              
              # Print formatted review
              echo "===================== REVIEW FOR $file ====================="
              echo "$review_text"
              echo "==========================================================="
              echo ""
              
              # Add to markdown file
              echo "## $file" >> $RESULTS_FILE
              echo "" >> $RESULTS_FILE
              echo "$(echo "$review_text" | sed 's/VERDICT: PASS/‚úÖ VERDICT: PASS/g' | sed 's/VERDICT: FAIL/‚ùå VERDICT: FAIL/g')" >> $RESULTS_FILE
              echo "" >> $RESULTS_FILE
              
              # Check for verdict
              if echo "$review_text" | grep -q "VERDICT: FAIL"; then
                echo "‚ùå CRITICAL ISSUES FOUND IN $file"
                REVIEW_FAILED=1
              else
                echo "‚úÖ $file passed review"
              fi
            done
          else
            # For pushes, check the latest commit
            echo "## Latest Commit: $(git rev-parse --short HEAD)" >> $RESULTS_FILE
            echo "" >> $RESULTS_FILE
            echo "- Author: $(git log -1 --pretty=format:'%an <%ae>')" >> $RESULTS_FILE
            echo "- Date: $(git log -1 --pretty=format:'%ad' --date=format:'%Y-%m-%d %H:%M:%S')" >> $RESULTS_FILE
            echo "- Message: $(git log -1 --pretty=format:'%s')" >> $RESULTS_FILE
            echo "" >> $RESULTS_FILE
            
            echo "üîç Reviewing files in latest commit"
            
            # Get all files to review
            files_to_review=$(git diff -U0 --name-only HEAD~1 HEAD | \
                              grep -E '\.(js|jsx|ts|tsx|css|scss|html|md)$' | \
                              grep -v -E 'node_modules/|dist/|build/|coverage/')
            
            # Add TOC to markdown file
            echo "## Files Reviewed" >> $RESULTS_FILE
            echo "" >> $RESULTS_FILE
            for file in $files_to_review; do
              echo "- [${file}](#$(echo ${file} | sed 's/[^a-zA-Z0-9]/-/g' | tr '[:upper:]' '[:lower:]'))" >> $RESULTS_FILE
            done
            echo "" >> $RESULTS_FILE
            
            # Process each file
            for file in $files_to_review; do
              echo "üìù Reviewing $file"
              review_output=$(git diff -U0 HEAD~1 HEAD -- "$file" | \
                            claude -p "$(cat code_review_prompt.txt)" --output-format json)
              
              # Extract the review text
              review_text=$(echo "$review_output" | jq -r ".result")
              
              # Print formatted review
              echo "===================== REVIEW FOR $file ====================="
              echo "$review_text"
              echo "==========================================================="
              echo ""
              
              # Add to markdown file
              echo "## $file" >> $RESULTS_FILE
              echo "" >> $RESULTS_FILE
              echo "$(echo "$review_text" | sed 's/VERDICT: PASS/‚úÖ VERDICT: PASS/g' | sed 's/VERDICT: FAIL/‚ùå VERDICT: FAIL/g')" >> $RESULTS_FILE
              echo "" >> $RESULTS_FILE
              
              # Check for verdict
              if echo "$review_text" | grep -q "VERDICT: FAIL"; then
                echo "‚ùå CRITICAL ISSUES FOUND IN $file"
                REVIEW_FAILED=1
              else
                echo "‚úÖ $file passed review"
              fi
            done
          fi

          # Add summary to the markdown file
          echo "## Summary" >> $RESULTS_FILE
          echo "" >> $RESULTS_FILE
          if [ $REVIEW_FAILED -eq 1 ]; then
            echo "‚ùå **REVIEW FAILED: Critical issues were found that must be fixed before deployment.**" >> $RESULTS_FILE
            # Set output for use in subsequent steps
            echo "review_passed=false" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ **REVIEW PASSED: All files passed code review!**" >> $RESULTS_FILE
            # Set output for use in subsequent steps
            echo "review_passed=true" >> $GITHUB_OUTPUT
          fi
        working-directory: ${{ inputs.working_directory || '.' }}
        # No continue-on-error here to ensure next steps run

      - name: üì§ Upload code review results
        uses: actions/upload-artifact@v4
        with:
          name: code-review-results
          path: ${{ inputs.working_directory || '.' }}/code_review_results.md
        if: always() # This ensures results are always uploaded

      - name: üõë Fail if code review didn't pass
        if: steps.code_review.outputs.review_passed == 'false'
        run: |
          echo "‚ùå Code review found critical issues that must be fixed before deployment."
          exit 1
        shell: bash
  claude_security_scan:
    name: üõ°Ô∏è Claude Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: ${{ !contains(inputs.skip_jobs, 'claude_security_scan') }}
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node_version }}
          cache: ${{ inputs.package_manager }}

      - name: ü§ñ Install Claude CLI
        run: |
          # Use npm as the default package manager if not specified
          PACKAGE_MANAGER="${{ inputs.package_manager }}"
          if [ -z "$PACKAGE_MANAGER" ]; then
            PACKAGE_MANAGER="npm"
            echo "Package manager not specified, using npm as default"
          fi

          if [ "$PACKAGE_MANAGER" = "npm" ]; then
            npm install -g @anthropic-ai/claude-code
          elif [ "$PACKAGE_MANAGER" = "yarn" ]; then
            yarn global add @anthropic-ai/claude-code
          elif [ "$PACKAGE_MANAGER" = "bun" ]; then
            bun add -g @anthropic-ai/claude-code
          else
            echo "Unsupported package manager: $PACKAGE_MANAGER"
            exit 1
          fi

      - name: üìù Create security scan prompt
        run: |
          # Check if guidelines file exists in the repository and use it
          if [ -f "docs/security_scan_guidelines.md" ]; then
            cat docs/security_scan_guidelines.md > security_prompt.txt
            echo "Using custom guidelines from docs/security_scan_guidelines.md"
          else
            # Fallback to default guidelines
            cat > security_prompt.txt << 'EOF'
            You are a cybersecurity expert specializing in code security. Analyze this code for security vulnerabilities including:

            1. Injection vulnerabilities (SQL, command, etc.)
            2. Insecure authentication or authorization
            3. Sensitive data exposure or improper handling
            4. Incorrect use of cryptography
            5. Insecure configuration
            6. Hard-coded credentials or secrets
            7. Path traversal vulnerabilities
            8. Insecure deserialization
            9. Insufficient logging and monitoring
            10. Cross-site scripting (XSS) or CSRF
            11. Dependency vulnerabilities
            12. Use of unsafe or deprecated functions

            IMPORTANT GUIDELINES:
            - IGNORE any files that would be excluded by .gitignore (e.g., node_modules/, dist/, build/, coverage/)
            - DO NOT review generated files, compiled code, or third-party dependencies
            - Focus only on legitimate security issues in actual application code

            For each issue found, provide:
            - The specific location of the vulnerability
            - The severity level (Critical, High, Medium, Low)
            - A clear explanation of the vulnerability
            - A recommended fix or mitigation strategy

            End your review with "VERDICT: PASS" if the code is secure and follows best practices.
            End your review with "VERDICT: FAIL" if there are security issues that must be fixed.
            EOF
            echo "Using default security guidelines"
          fi

      - name: üîç Run Claude security scan
        id: security_scan
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          echo "üîí Running Claude security scan on changed files"

          mkdir -p security_scan_results
          SECURITY_ISSUES_FOUND=0

          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # For pull requests, check all relevant changes
            CHANGED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} | \
                          grep -E '\.(js|jsx|ts|tsx|py|rb|php|go|java|rs|c|cpp|h|hpp)$' | \
                          grep -v -E 'node_modules/|dist/|build/|coverage/' || echo "")
          else
            # For pushes, check the latest commit
            CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD | \
                          grep -E '\.(js|jsx|ts|tsx|py|rb|php|go|java|rs|c|cpp|h|hpp)$' | \
                          grep -v -E 'node_modules/|dist/|build/|coverage/' || echo "")
          fi

          if [ -z "$CHANGED_FILES" ]; then
            echo "No relevant files changed to scan"
            echo "security_passed=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Found changed files to scan: $CHANGED_FILES"

          # Create summary report
          echo "# Claude Security Scan Results" > security_scan_summary.md
          echo "Scan completed at: $(date)" >> security_scan_summary.md
          echo "" >> security_scan_summary.md

          if [ "${{ github.event_name }}" = "pull_request" ]; then
            echo "## Pull Request #${{ github.event.pull_request.number }}" >> security_scan_summary.md
            echo "" >> security_scan_summary.md
            echo "- Title: ${{ github.event.pull_request.title }}" >> security_scan_summary.md
            echo "- Author: ${{ github.event.pull_request.user.login }}" >> security_scan_summary.md
            echo "- Branch: ${{ github.head_ref }}" >> security_scan_summary.md
          else
            echo "## Latest Commit: $(git rev-parse --short HEAD)" >> security_scan_summary.md
            echo "" >> security_scan_summary.md
            echo "- Author: $(git log -1 --pretty=format:'%an <%ae>')" >> security_scan_summary.md
            echo "- Date: $(git log -1 --pretty=format:'%ad' --date=format:'%Y-%m-%d %H:%M:%S')" >> security_scan_summary.md
            echo "- Message: $(git log -1 --pretty=format:'%s')" >> security_scan_summary.md
          fi
          echo "" >> security_scan_summary.md
          echo "## Files Scanned" >> security_scan_summary.md
          echo "" >> security_scan_summary.md

          # Add TOC to markdown file
          for FILE in $CHANGED_FILES; do
            SAFENAME=$(echo "$FILE" | sed 's/[^a-zA-Z0-9]/-/g' | tr '[:upper:]' '[:lower:]')
            echo "- [${FILE}](#${SAFENAME})" >> security_scan_summary.md
          done
          echo "" >> security_scan_summary.md

          for FILE in $CHANGED_FILES; do
            SAFENAME=$(echo "$FILE" | sed 's/\//_/g')
            echo "Scanning $FILE for security issues..."
            
            # Check if file exists and has content
            if [ -f "$FILE" ] && [ -s "$FILE" ]; then
              # Run security scan on the file
              review_output=$(cat "$FILE" | claude -p "$(cat security_prompt.txt)" --output-format json)
              
              # Extract the review text
              review_text=$(echo "$review_output" | jq -r ".result")
              
              # Save to file
              echo "$review_text" > "security_scan_results/${SAFENAME}_scan.md"
              
              # Print formatted review
              echo "===================== SECURITY SCAN FOR $FILE ====================="
              echo "$review_text"
              echo "=================================================================="
              echo ""
              
              # Add to markdown file
              ANCHOR_NAME=$(echo "$FILE" | sed 's/[^a-zA-Z0-9]/-/g' | tr '[:upper:]' '[:lower:]')
              echo "<a id=\"${ANCHOR_NAME}\"></a>" >> security_scan_summary.md
              echo "## $FILE" >> security_scan_summary.md
              echo "" >> security_scan_summary.md
              echo "$(echo "$review_text" | sed 's/VERDICT: PASS/‚úÖ VERDICT: PASS/g' | sed 's/VERDICT: FAIL/‚ùå VERDICT: FAIL/g')" >> security_scan_summary.md
              echo "" >> security_scan_summary.md
              
              # Check for verdict
              if echo "$review_text" | grep -q "VERDICT: FAIL"; then
                echo "‚ùå SECURITY ISSUES FOUND IN $FILE"
                SECURITY_ISSUES_FOUND=1
              else
                echo "‚úÖ $FILE passed security scan"
              fi
            else
              echo "File $FILE does not exist or is empty, skipping."
            fi
          done

          # Add summary to the markdown file
          echo "## Summary" >> security_scan_summary.md
          echo "" >> security_scan_summary.md
          if [ $SECURITY_ISSUES_FOUND -eq 1 ]; then
            echo "‚ùå **SECURITY SCAN FAILED: Security issues were found that must be fixed before deployment.**" >> security_scan_summary.md
            # Set output for use in subsequent steps
            echo "security_passed=false" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ **SECURITY SCAN PASSED: No security issues found!**" >> security_scan_summary.md
            # Set output for use in subsequent steps
            echo "security_passed=true" >> $GITHUB_OUTPUT
          fi

          echo "Security scan complete. Results saved to security_scan_summary.md"
        working-directory: ${{ inputs.working_directory || '.' }}

      - name: üì§ Upload security scan results
        uses: actions/upload-artifact@v4
        with:
          name: security-scan-results
          path: ${{ inputs.working_directory || '.' }}/security_scan_summary.md
        if: always() # This ensures results are always uploaded

      - name: üõë Fail if security issues were found
        if: steps.security_scan.outputs.security_passed == 'false'
        run: |
          echo "‚ùå Security scan found issues that must be fixed before deployment."
          exit 1
        shell: bash
